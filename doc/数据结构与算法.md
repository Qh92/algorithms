# 数据结构与算法



## 第一节课



### 时间复杂度

算法流程按照最差情况来估计**时间复杂度**



### 对数器的概念和使用

```markdown
1.有一个你想要测的方法a
2.实现复杂度不好但是容易实现的方法b
3.实现一个随机样本产生器
4.把方法a和方法b跑相同的随机样本，看看得到的结果是否一样
5.如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者方法b
6.当样本数量很多时比对测试依然正确，可以确定方法a已经正确
```







### 1.异或运算

两值相等异或为0，两值不等异或为1。异或运算可以理解为**无进位相加**

```java
int a = 10110;
int b = 00111;
a ^ b = 10001;
```

#### 特性：

1）0 ^ N = N   N ^ N = 0

2）异或运算满足交换律、结合律

a ^ b = b ^ a; (a ^ b) ^ c = a ^ (b ^ c);

3）有多个数异或成为N，这些数谁先异或谁后异或无关，结果都一样。

eg.

```java
//注意：能这么玩的前提是 a,b在内存中是两块独立的区域
int a = 10;
int b = 33;
a = a ^ b;
b = a ^ b;// b = a ^ b ^ b = a ^ (b ^ b) = a ^ 0 = a;
a = a ^ b;// a = a ^ b ^ a = b ^ (a ^ a) = b;
//最终a、b数值交换
```



#### 面试题：

1、给定一个整型数组，

如果其中只有一种数出现奇数次，其它数都出现偶数次，求出现奇数次的数

```java
int[] arr = {1,2,3,2,3,4,5,1,4};
int value = 0;
for (int val : arr) {
    value ^= val;
}
// 5
System.out.println(value);
```



如果其中有两种数出现奇数次，其它数都出现偶数次，求出现奇数次的两个数

```java
//如果其中有两种数出现奇数次，其它数都出现偶数次，求出现奇数次的两个数
int[] arr2 = {1,2,3,2,3,4,5,1,4,6};
//最终异或出来的结果为 两个奇数次的数异或出来的结果
int eor1 = 0;
for (int val : arr2) {
    eor1 ^= val;
}

//更优解法
// eor1 != 0,eor1必然有一个位置上是1
// 提取出最右的1
int rightOne = eor1 & (~eor1 + 1);

int onlyOne = 0;
for (int val : arr2) {
    if ((val & rightOne) == 0) {
        onlyOne ^= val;
    }
}
// 6 5
System.out.println(onlyOne + " " + (eor1 ^ onlyOne));
```



注：要求时间复杂度O(n)，空间复杂度O(1)



## 第二节课

![image-20211230230335795](assets\image-20211230230335795.png)





![image-20211230230948417](assets\image-20211230230948417.png)